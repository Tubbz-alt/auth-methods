<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <script src="../../iron-test-helpers/mock-interactions.js"></script>
    <link rel="import" href="../../arc-polyfills/arc-polyfills.html">
    <script src="amf-loader.js"></script>
    <link rel="import" href="../auth-method-oauth2.html">
  </head>
  <body>
    <test-fixture id="authorizationCode">
      <template>
        <auth-method-oauth2 grant-type="authorization_code"></auth-method-oauth2>
      </template>
    </test-fixture>
    <script>
    /* global AmfLoader, MockInteractions, sinon */
    suite('Password grant type', () => {
      let element;
      const clientId = '821776164331-rserncqpdsq32lmbf5cfeolgcoujb6fm.apps.googleusercontent.com';
      const authorizationUri = 'https://accounts.google.com/o/oauth2/v2/auth';
      const accessTokenUri = 'https://www.googleapis.com/oauth2/v4/token';
      const clientSecret = 'test-secret';
      const redirectUri = 'https://redirect';
      const scopes = ['email', 'profile'];

      suite('Validation', () => {
        setup((done) => {
          element = fixture('authorizationCode');
          element.clientId = clientId;
          element.authorizationUri = authorizationUri;
          element.clientSecret = clientSecret;
          element.accessTokenUri = accessTokenUri;
          element.redirectUri = redirectUri;
          Polymer.RenderStatus.afterNextRender(this, () => {
            flush(() => done());
          });
        });

        test('Should not be validated', () => {
          element.accessTokenUri = undefined;
          assert.isFalse(element.validate(), 'Active validation.');
        });

        test('Should be validated', () => {
          assert.isTrue(element.validate());
        });

        test('Should not fire oauth2-token-requested event', () => {
          let spy = sinon.stub();
          element.accessTokenUri = undefined;
          element.addEventListener('oauth2-token-requested', spy);
          let button = element.shadowRoot.querySelector('.auth-button');
          MockInteractions.tap(button);
          assert.isFalse(spy.calledOnce);
        });

        test('Fire oauth2-token-requested event', (done) => {
          element.scopes = scopes;
          flush(() => {
            const spy = sinon.stub();
            element.addEventListener('oauth2-token-requested', spy);
            const button = element.shadowRoot.querySelector('.auth-button');
            MockInteractions.tap(button);
            assert.isTrue(spy.calledOnce);
            done();
          });
        });
      });

      suite('Fields visibility', () => {
        suiteSetup(() => {
          sessionStorage.clear();
        });

        setup((done) => {
          element = fixture('authorizationCode');
          Polymer.RenderStatus.afterNextRender(this, () => {
            flush(() => done());
          });
        });

        teardown(() => {
          sessionStorage.clear();
        });

        test('Step 1 is closed per auto selection', () => {
          assert.isTrue(element.isSelectedType);
          const node = element.shadowRoot.querySelector('auth-method-step[step="1"]');
          assert.isTrue(node.inactive);
        });

        test('Client id is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="clientid"]');
          assert.isTrue(node.required);
        });

        test('Client id is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="clientid"]');
          assert.isTrue(node.required);
        });

        test('Client secret is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="clientsecret"]');
          assert.isTrue(node.required);
        });

        test('Client secret is not disabled', () => {
          const node = element.shadowRoot.querySelector('[data-input="clientsecret"]');
          assert.isFalse(node.disabled);
        });

        test('Client secret is not hidden', () => {
          const node = element.shadowRoot.querySelector('[data-input="clientsecret"]');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'block');
        });

        test('Advanced settings checkbox is not rendered', () => {
          const node = element.shadowRoot.querySelector('.adv-settings-input');
          assert.notOk(node);
        });

        test('Authorization URI is not hidden', () => {
          const node = element.shadowRoot.querySelector('[data-input="authuri"]');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'block');
        });

        test('Authorization URI is not disabled', () => {
          const node = element.shadowRoot.querySelector('[data-input="authuri"]');
          assert.isFalse(node.disabled);
        });

        test('Authorization URI is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="authuri"]');
          assert.isTrue(node.required);
        });

        test('Access token URI is not hidden', () => {
          const node = element.shadowRoot.querySelector('[data-input="tokenuri"]');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'block');
        });

        test('Access token URI is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="tokenuri"]');
          assert.isTrue(node.required);
        });

        test('Access token URI is not disabled', () => {
          const node = element.shadowRoot.querySelector('[data-input="tokenuri"]');
          assert.isFalse(node.disabled);
        });

        test('Username is hidden', () => {
          const node = element.shadowRoot.querySelector('[data-input="username"]');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'none');
        });

        test('Username is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="username"]');
          assert.isTrue(node.required);
        });

        test('Username is disabled', () => {
          const node = element.shadowRoot.querySelector('[data-input="username"]');
          assert.isTrue(node.disabled);
        });

        test('Password is hidden', () => {
          const node = element.shadowRoot.querySelector('[data-input="password"]');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'none');
        });

        test('Password is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="password"]');
          assert.isTrue(node.required);
        });

        test('Password is disabled', () => {
          const node = element.shadowRoot.querySelector('[data-input="password"]');
          assert.isTrue(node.disabled);
        });

        test('Scope selector is not hidden', () => {
          const node = element.shadowRoot.querySelector('oauth2-scope-selector');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'block');
        });

        test('Request access token button is rendered', () => {
          const node = element.shadowRoot.querySelector('.authorize-actions');
          const display = getComputedStyle(node).display;
          assert.notEqual(display, 'none');
        });

        test('current-token section is hidden', () => {
          const node = element.shadowRoot.querySelector('.current-token');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'none');
        });
      });

      suite('Events', () => {
        setup((done) => {
          element = fixture('authorizationCode');
          element.clientId = clientId;
          element.authorizationUri = authorizationUri;
          element.clientSecret = clientSecret;
          element.accessTokenUri = accessTokenUri;
          element.redirectUri = redirectUri;
          element.scopes = scopes;
          Polymer.RenderStatus.afterNextRender(this, () => {
            flush(() => done());
          });
        });

        test('oauth2-token-requested event contains state parameter', () => {
          let eventData;
          element.addEventListener('oauth2-token-requested', function clb(e) {
            element.removeEventListener('oauth2-token-requested', clb);
            eventData = e.detail;
          });
          let button = element.shadowRoot.querySelector('.auth-button');
          MockInteractions.tap(button);
          assert.typeOf(eventData.state, 'string');
        });

        test('oauth2-token-requested event contains all required data', (done) => {
          element.addEventListener('oauth2-token-requested', function clb(e) {
            element.removeEventListener('oauth2-token-requested', clb);
            assert.equal(e.detail.type, 'authorization_code', 'type is set');
            assert.equal(e.detail.clientId, clientId, 'clientId is set');
            assert.equal(e.detail.clientSecret, clientSecret, 'clientSecret is set');
            assert.equal(e.detail.accessTokenUri, accessTokenUri, 'accessTokenUri is set');
            assert.equal(e.detail.accessToken, '', 'accessToken is empty');
            assert.typeOf(e.detail.customData, 'object', 'customData is set');
            assert.equal(e.detail.authorizationUri, authorizationUri, 'authorizationUrl is set');
            assert.equal(e.detail.redirectUri, redirectUri, 'redirectUri is set');
            assert.typeOf(e.detail.scopes, 'array', 'scopes is set');
            done();
          });
          element.authorize();
        });
      });

      suite('getSettings()', () => {
        let element;
        setup(() => {
          element = fixture('authorizationCode');
          element.clientId = clientId;
          element.authorizationUri = authorizationUri;
          element.redirectUri = redirectUri;
          element.scopes = scopes;
          element.clientSecret = clientSecret;
          element.accessTokenUri = accessTokenUri;
        });

        test('Returns an object', () => {
          let result = element.getSettings();
          assert.typeOf(result, 'object');
        });

        test('type is set', () => {
          let result = element.getSettings();
          assert.equal(result.type, element.grantType);
        });

        test('clientId is set', () => {
          let result = element.getSettings();
          assert.equal(result.clientId, clientId);
        });

        test('accessToken is set', () => {
          let result = element.getSettings();
          assert.equal(result.accessToken, '', 'Token value is empty');

          element.accessToken = 'test-token';
          result = element.getSettings();
          assert.equal(result.accessToken, element.accessToken, 'Token value is set');
        });

        test('authorizationUri is set', () => {
          let result = element.getSettings();
          assert.equal(result.authorizationUri, authorizationUri);
        });

        test('redirectUri is set', () => {
          let result = element.getSettings();
          assert.equal(result.redirectUri, redirectUri);
        });

        test('scopes is set', () => {
          let result = element.getSettings();
          assert.isTrue(result.scopes === scopes);
        });

        test('clientSecret is set', () => {
          let result = element.getSettings();
          assert.equal(result.clientSecret, clientSecret);
        });

        test('accessTokenUri is set', () => {
          let result = element.getSettings();
          assert.equal(result.accessTokenUri, accessTokenUri);
        });

        test('Custom values are empty', () => {
          const result = element.getSettings();
          assert.isUndefined(result.customData.auth.parameters, 'auth params is not set');
          assert.isUndefined(result.customData.token.parameters, 'token params is not set');
          assert.isUndefined(result.customData.token.headers, 'token headers is not set');
          assert.isUndefined(result.customData.token.body, 'token body is not set');
        });

        test('deliveryMethod is set', () => {
          const result = element.getSettings();
          assert.equal(result.deliveryMethod, 'header', 'default value is set');
        });

        test('deliveryName is set', () => {
          const result = element.getSettings();
          assert.equal(result.deliveryName, 'authorization', 'default value is set');
        });
      });

      suite('getSettings() - custom data', () => {
        let amf;
        suiteSetup(() => {
          return AmfLoader.load()
          .then((model) => amf = model);
        });

        let element;
        setup((done) => {
          element = fixture('authorizationCode');
          element.amfSettings = amf;
          element.grantType = 'authorization_code';
          Polymer.RenderStatus.afterNextRender(this, () => {
            flush(() => done());
          });
        });

        test('Contains only required params', () => {
          const result = element.getSettings();
          assert.typeOf(result.customData.auth.parameters, 'array', 'auth params is an array');
          assert.lengthOf(result.customData.auth.parameters, 1, 'has one item');
          assert.typeOf(result.customData.token.body, 'array', 'token body is an array');
          assert.lengthOf(result.customData.token.body, 1, 'has one item');
          assert.isUndefined(result.customData.token.headers, 'token headers is not set');
        });

        test('Contains not required data when added', () => {
          const value = 1234;
          element.authQueryParameters[0].value = value;
          const result = element.getSettings();
          assert.lengthOf(result.customData.auth.parameters, 2, 'has one item');
          assert.equal(result.customData.auth.parameters[0].value, value);
        });

        test('deliveryMethod is set', () => {
          const result = element.getSettings();
          assert.equal(result.deliveryMethod, 'query', 'Custom value is set');
        });

        test('deliveryName is set', () => {
          const result = element.getSettings();
          assert.equal(result.deliveryName, 'access_token', 'Custom value is set');
        });

        test('deliveryMethod is restored to default', () => {
          element.amfSettings = undefined;
          const result = element.getSettings();
          assert.equal(result.deliveryMethod, 'header');
        });

        test('deliveryName is restored to default', () => {
          element.amfSettings = undefined;
          const result = element.getSettings();
          assert.equal(result.deliveryName, 'authorization');
        });
      });
    });

    </script>
  </body>
</html>
