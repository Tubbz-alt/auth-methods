<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <script src="../../iron-test-helpers/mock-interactions.js"></script>
    <link rel="import" href="../../arc-polyfills/arc-polyfills.html">
    <link rel="import" href="../auth-method-custom.html">
    <script src="amf-loader.js"></script>
  </head>
  <body>
    <test-fixture id="custom">
      <template>
        <auth-method-custom></auth-method-custom>
      </template>
    </test-fixture>

    <script>
    /* global AmfLoader, MockInteractions */
    suite('custom auth', () => {
      let amf;
      let element;
      suiteSetup(() => {
        return AmfLoader.load(5)
        .then((model) => amf = model);
      });

      suite('Basic', () => {
        setup((done) => {
          element = fixture('custom');
          element.amfSettings = amf;
          Polymer.RenderStatus.afterNextRender(this, () => {
            flush(() => done());
          });
        });

        test('headers is computed', () => {
          assert.typeOf(element.headers, 'array');
          assert.lengthOf(element.headers, 1);
        });

        test('queryParameters is computed', () => {
          assert.typeOf(element.queryParameters, 'array');
          assert.lengthOf(element.queryParameters, 2);
        });

        test('hasHeaders is computed', () => {
          assert.isTrue(element.hasHeaders);
        });

        test('hasQueryParameters is computed', () => {
          assert.isTrue(element.hasQueryParameters);
        });

        test('schemeName is computed', () => {
          assert.equal(element.schemeName, 'custom1');
        });

        test('schemeDescription is computed', () => {
          assert.typeOf(element.schemeDescription, 'string');
        });
      });

      suite('Validation', () => {
        setup((done) => {
          element = fixture('custom');
          element.amfSettings = amf;
          Polymer.RenderStatus.afterNextRender(this, () => {
            flush(() => done());
          });
        });

        test('Should not be validated', () => {
          assert.isFalse(element.validate());
        });

        test('Should be validated', (done) => {
          const hInput = element.shadowRoot.querySelector('[data-type="header"]');
          hInput.value = 'test';
          const qInput = element.shadowRoot.querySelector('.query-section .param-item:nth-child(2) [data-type="query"]');
          qInput.value = 'true';
          flush(() => {
            assert.isTrue(element.validate());
            done();
          });
        });
      });

      suite('getSettings()', () => {
        setup((done) => {
          element = fixture('custom');
          element.amfSettings = amf;
          Polymer.RenderStatus.afterNextRender(this, () => {
            flush(() => done());
          });
        });

        test('Returns an object', () => {
          const result = element.getSettings();
          assert.typeOf(result, 'object');
        });

        test('Has all keys', () => {
          const result = element.getSettings();
          const keys = Object.keys(result);
          assert.lengthOf(keys, 3);
        });
      });

      suite('Docs', () => {
        setup((done) => {
          element = fixture('custom');
          element.amfSettings = amf;
          Polymer.RenderStatus.afterNextRender(this, () => {
            flush(() => done());
          });
        });

        test('Main documentation is not rendered', () => {
          assert.isUndefined(element.documentationOpened);
        });

        test('Toggles main documentation', () => {
          const button = element.shadowRoot.querySelector('.scheme-header paper-icon-button');
          MockInteractions.tap(button);
          assert.isTrue(element.documentationOpened);
        });

        test('Renders item documentation', () => {
          const button = element.shadowRoot.querySelector('.header-item .help-icon');
          MockInteractions.tap(button);
          const marked = element.shadowRoot.querySelector('.header-item .data-docs marked-element');
          assert.ok(marked);
          assert.typeOf(marked.markdown, 'string');
        });

        test('Item collapse is opened', () => {
          const button = element.shadowRoot.querySelector('.header-item .help-icon');
          MockInteractions.tap(button);
          const collapse = element.shadowRoot.querySelector('.header-item .data-docs iron-collapse');
          assert.isTrue(collapse.opened);
        });

        test('Another click closes collapse', (done) => {
          const button = element.shadowRoot.querySelector('.header-item .help-icon');
          MockInteractions.tap(button);
          const collapse = element.shadowRoot.querySelector('.header-item .data-docs iron-collapse');
          assert.isTrue(collapse.opened);
          flush(() => {
            MockInteractions.tap(button);
            assert.isFalse(collapse.opened);
            done();
          });
        });

        test('Docs are cleared when scheme change', (done) => {
          const button = element.shadowRoot.querySelector('.header-item .help-icon');
          MockInteractions.tap(button);
          flush(() => {
            element.amfSettings = undefined;
            const collapse = element.shadowRoot.querySelector('.header-item .data-docs iron-collapse');
            assert.equal(collapse, null);
            done();
          });
        });
      });

      suite('Settings change event', () => {

        suiteSetup(() => {
          sessionStorage.clear();
        });

        setup((done) => {
          element = fixture('custom');
          element.amfSettings = amf;
          Polymer.RenderStatus.afterNextRender(this, () => {
            flush(() => done());
          });
        });

        teardown(() => {
          sessionStorage.clear();
        });

        test('Dispatches the event', (done) => {
          element.addEventListener('auth-settings-changed', () => {
            done();
          });
          const input = element.shadowRoot.querySelector('[data-type="header"]');
          input.value = 'test-x';
        });

        test('The event has required properties', (done) => {
          const hInput = element.shadowRoot.querySelector('[data-type="header"]');
          hInput.value = 'test-y';
          const qInput = element.shadowRoot.querySelector('.query-section .param-item:nth-child(2) [data-type="query"]');
          element.addEventListener('auth-settings-changed', (e) => {
            assert.equal(e.detail.type, 'x-custom', 'type is set');
            assert.equal(e.detail.valid, true, 'valid is set');
            assert.equal(e.detail.name, 'custom1', 'name is set');
            assert.typeOf(e.detail.settings, 'object', 'settings is set');
            done();
          });
          qInput.value = 'true';
        });
      });

      suite('Params change event', () => {
        setup((done) => {
          element = fixture('custom');
          element.amfSettings = amf;
          Polymer.RenderStatus.afterNextRender(this, () => {
            flush(() => done());
          });
        });

        test('request-header-changed is dispatched', (done) => {
          element.addEventListener('request-header-changed', (e) => {
            assert.equal(e.detail.name, 'SpecialToken', 'name is set');
            assert.equal(e.detail.value, 'test-value', 'value is set');
            done();
          });
          const input = element.shadowRoot.querySelector('[data-type="header"]');
          input.value = 'test-value';
        });

        test('query-parameter-changed is dispatched', (done) => {
          element.addEventListener('query-parameter-changed', (e) => {
            assert.equal(e.detail.name, 'debugToken', 'name is set');
            assert.equal(e.detail.value, 'Error', 'value is set');
            done();
          });
          const input = element.shadowRoot.querySelector('[data-type="query"]');
          input.value = 'Error';
        });
      });

      suite('Updates headers from event', () => {
        function fire(name) {
          document.body.dispatchEvent(new CustomEvent('request-header-changed', {
            detail: {
              name: name,
              value: 'test-value'
            },
            bubbles: true,
            composed: true
          }));
        }
        setup((done) => {
          element = fixture('custom');
          element.amfSettings = amf;
          Polymer.RenderStatus.afterNextRender(this, () => {
            flush(() => done());
          });
        });

        test('Updated existing header', () => {
          fire('SpecialToken');
          assert.lengthOf(element.headers, 1);
          assert.equal(element.headers[0].value, 'test-value');
        });

        test('Does nothing when header not found', () => {
          fire('other');
          assert.lengthOf(element.headers, 1);
          // Model transformer caches model so it resutls with last value
          assert.equal(element.headers[0].value, 'test-value');
        });
      });

      suite('Updates query params from event', () => {
        function fire(name, value) {
          document.body.dispatchEvent(new CustomEvent('query-parameter-changed', {
            detail: {
              name: name,
              value: value
            },
            bubbles: true,
            composed: true
          }));
        }
        setup((done) => {
          element = fixture('custom');
          element.amfSettings = amf;
          Polymer.RenderStatus.afterNextRender(this, () => {
            flush(() => done());
          });
        });

        test('Updated existing parameter', () => {
          fire('debugToken', 'Error');
          assert.lengthOf(element.queryParameters, 2);
          assert.equal(element.queryParameters[0].value, 'Error');
        });

        test('Does nothing when header not found', () => {
          fire('other', '');
          assert.lengthOf(element.queryParameters, 2);
          // Model transformer caches model so it resutls with last value
          assert.equal(element.queryParameters[0].value, 'Error');
        });
      });
    });
    </script>

  </body>
</html>
