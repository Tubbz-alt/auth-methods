<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

    <script src="../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../node_modules/@polymer/test-fixture/test-fixture.js"></script>
    <script src="../node_modules/mocha/mocha.js"></script>
    <script src="../node_modules/chai/chai.js"></script>
    <script src="../node_modules/wct-mocha/wct-mocha.js"></script>
    <script src="../node_modules/sinon/pkg/sinon.js"></script>

  </head>
  <body>
    <test-fixture id="implicit">
      <template>
        <auth-method-oauth2 grant-type="implicit"></auth-method-oauth2>
      </template>
    </test-fixture>

    <test-fixture id="empty">
      <template>
        <auth-method-oauth2></auth-method-oauth2>
      </template>
    </test-fixture>

    <script type="module">
    import '../auth-method-oauth2.js';
    import {afterNextRender} from '@polymer/polymer/lib/utils/render-status.js';
    import {tap} from '@polymer/iron-test-helpers/mock-interactions.js';
    import {AmfLoader} from './amf-loader.js';
    suite('Implicit grant type', () => {
      let element;
      const clientId = '821776164331-rserncqpdsq32lmbf5cfeolgcoujb6fm.apps.googleusercontent.com';
      const authorizationUri = 'https://accounts.google.com/o/oauth2/v2/auth';
      const redirectUri = 'https://redirect';
      const scopes = ['email', 'profile'];

      function clearCache() {
        sessionStorage.clear();
        const factory = document.createElement('api-view-model-transformer');
        factory.clearCache();
      }

      suite('Validation', () => {
        setup((done) => {
          clearCache();
          element = fixture('implicit');
          element.clientId = clientId;
          element.authorizationUri = authorizationUri;
          afterNextRender(window, () => {
            done();
          });
        });

        test('Should not be validated', () => {
          assert.isFalse(element.validate(), 'Active validation.');
        });

        test('Should be validated', (done) => {
          element.scopes = ['email', 'profile'];
          flush(() => {
            assert.isTrue(element.validate());
            done();
          });
        });

        test('Should not fire oauth2-token-requested event', () => {
          const spy = sinon.stub();
          element.addEventListener('oauth2-token-requested', spy);
          const button = element.shadowRoot.querySelector('.auth-button');
          tap(button);
          assert.isFalse(spy.calledOnce);
        });

        test('Fire oauth2-token-requested event when validated', (done) => {
          element.scopes = ['email', 'profile'];
          flush(() => {
            const spy = sinon.stub();
            element.addEventListener('oauth2-token-requested', spy);
            const button = element.shadowRoot.querySelector('.auth-button');
            tap(button);
            assert.isTrue(spy.calledOnce);
            done();
          });
        });
      });

      suite('Fields visibility', () => {
        suiteSetup(() => {
          sessionStorage.clear();
        });

        setup((done) => {
          clearCache();
          element = fixture('implicit');
          afterNextRender(window, () => {
            flush(() => done());
          });
        });

        test('Step 1 is closed per auto selection', () => {
          assert.isTrue(element.isSelectedType);
          const node = element.shadowRoot.querySelector('auth-method-step[step="1"]');
          assert.isTrue(node.inactive);
        });

        test('Client id is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="clientid"]');
          assert.isTrue(node.required);
        });

        test('Client id is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="clientid"]');
          assert.isTrue(node.required);
        });

        test('Client secret is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="clientsecret"]');
          assert.isTrue(node.required);
        });

        test('Client secret is disabled', () => {
          const node = element.shadowRoot.querySelector('[data-input="clientsecret"]');
          assert.isTrue(node.disabled);
        });

        test('Client secret is hidden', () => {
          const node = element.shadowRoot.querySelector('[data-input="clientsecret"]');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'none');
        });

        test('Advanced settings checkbox is not rendered', () => {
          const node = element.shadowRoot.querySelector('.adv-settings-input');
          assert.notOk(node);
        });

        test('Authorization URI is not hidden', () => {
          const node = element.shadowRoot.querySelector('[data-input="authuri"]');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'block');
        });

        test('Authorization URI is not disabled', () => {
          const node = element.shadowRoot.querySelector('[data-input="authuri"]');
          assert.isFalse(node.disabled);
        });

        test('Authorization URI is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="authuri"]');
          assert.isTrue(node.required);
        });

        test('Access token URI is hidden', () => {
          const node = element.shadowRoot.querySelector('[data-input="tokenuri"]');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'none');
        });

        test('Access token URI is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="tokenuri"]');
          assert.isTrue(node.required);
        });

        test('Access token URI is disabled', () => {
          const node = element.shadowRoot.querySelector('[data-input="tokenuri"]');
          assert.isTrue(node.disabled);
        });

        test('Username is hidden', () => {
          const node = element.shadowRoot.querySelector('[data-input="username"]');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'none');
        });

        test('Username is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="username"]');
          assert.isTrue(node.required);
        });

        test('Username is disabled', () => {
          const node = element.shadowRoot.querySelector('[data-input="username"]');
          assert.isTrue(node.disabled);
        });

        test('Password is hidden', () => {
          const node = element.shadowRoot.querySelector('[data-input="password"]');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'none');
        });

        test('Password is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="password"]');
          assert.isTrue(node.required);
        });

        test('Password is disabled', () => {
          const node = element.shadowRoot.querySelector('[data-input="password"]');
          assert.isTrue(node.disabled);
        });

        test('Scope selector is not hidden', () => {
          const node = element.shadowRoot.querySelector('oauth2-scope-selector');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'block');
        });

        test('Request access token button is rendered', () => {
          const node = element.shadowRoot.querySelector('.authorize-actions');
          const display = getComputedStyle(node).display;
          assert.notEqual(display, 'none');
        });

        test('current-token section is hidden', () => {
          const node = element.shadowRoot.querySelector('.current-token');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'none');
        });
      });

      suite('Events', () => {
        setup((done) => {
          clearCache();
          element = fixture('implicit');
          element.clientId = clientId;
          element.authorizationUri = authorizationUri;
          element.redirectUri = redirectUri;
          element.scopes = ['email', 'profile'];
          afterNextRender(window, () => {
            flush(() => {
              done();
            });
          });
        });

        test('oauth2-token-requested event contains state parameter', () => {
          let eventData;
          element.addEventListener('oauth2-token-requested', function clb(e) {
            element.removeEventListener('oauth2-token-requested', clb);
            eventData = e.detail;
          });
          let button = element.shadowRoot.querySelector('.auth-button');
          tap(button);
          assert.typeOf(eventData.state, 'string');
        });

        test('oauth2-token-requested event contains all required data', (done) => {
          element.addEventListener('oauth2-token-requested', function clb(e) {
            element.removeEventListener('oauth2-token-requested', clb);
            assert.equal(e.detail.type, 'implicit', 'type is set');
            assert.equal(e.detail.clientId, clientId, 'clientId is set');
            assert.equal(e.detail.accessToken, '', 'accessToken is empty');
            assert.typeOf(e.detail.customData, 'object', 'customData is set');
            assert.equal(e.detail.authorizationUri, authorizationUri, 'authorizationUri is set');
            assert.equal(e.detail.redirectUri, redirectUri, 'redirectUri is set');
            assert.typeOf(e.detail.scopes, 'array', 'scopes is set');
            done();
          });
          element.authorize();
        });
      });

      suite('getSettings()', () => {
        let element;
        setup(() => {
          clearCache();
          element = fixture('implicit');
          element.clientId = clientId;
          element.authorizationUri = authorizationUri;
          element.redirectUri = redirectUri;
          element.scopes = scopes;
        });

        test('Returns an object', () => {
          const result = element.getSettings();
          assert.typeOf(result, 'object');
        });

        test('type is set', () => {
          const result = element.getSettings();
          assert.equal(result.type, element.grantType);
        });

        test('clientId is set', () => {
          const result = element.getSettings();
          assert.equal(result.clientId, clientId);
        });

        test('accessToken is set', () => {
          let result = element.getSettings();
          assert.equal(result.accessToken, '', 'Token value is empty');
          element.accessToken = 'test-token';
          result = element.getSettings();
          assert.equal(result.accessToken, element.accessToken, 'Token value is set');
        });

        test('authorizationUri is set', () => {
          const result = element.getSettings();
          assert.equal(result.authorizationUri, authorizationUri);
        });

        test('redirectUri is set', () => {
          const result = element.getSettings();
          assert.equal(result.redirectUri, redirectUri);
        });

        test('scopes is set', () => {
          const result = element.getSettings();
          assert.isTrue(result.scopes === scopes);
        });

        test('Custom values are empty', function() {
          const result = element.getSettings();
          assert.isUndefined(result.customData.auth.parameters, 'auth params is not set');
          assert.isUndefined(result.customData.token, 'token is not set');
        });

        test('deliveryMethod is set', () => {
          const result = element.getSettings();
          assert.equal(result.deliveryMethod, 'header', 'default value is set');
        });

        test('deliveryName is set', () => {
          const result = element.getSettings();
          assert.equal(result.deliveryName, 'authorization', 'default value is set');
        });
      });

      suite('Amf model', () => {
        [
          ['Full data model', false],
          ['Compact data model', true]
        ].forEach((setupItem) => {
          suite(setupItem[0], function() {
            let amf;
            let security;
            let element;
            suiteSetup(() => {
              return AmfLoader.load(0, setupItem[1])
              .then((model) => {
                amf = model[0];
                security = model[1];
              });
            });

            setup(() => {
              clearCache();
              element = fixture('empty');
              element.amfModel = amf;
              element.amfSettings = security;
            });

            test('Computes authorizationUri', () => {
              assert.equal(element.authorizationUri, 'https://auth.com');
            });

            test('Computes accessTokenUri', () => {
              assert.equal(element.accessTokenUri, 'https://token.com');
            });

            test('Computes scopes', () => {
              assert.deepEqual(element.scopes, ['profile', 'email']);
            });

            test('Computes grant types', () => {
              const compare = [{
                  type: 'implicit',
                  label: 'Access token (browser flow)'
                }, {
                  type: 'authorization_code',
                  label: 'Authorization code (server flow)'
                }, {
                  label: 'annotated_custom_grant',
                  type: 'annotated_custom_grant'
                }, {
                  label: 'annotated_custom_grant2',
                  type: 'annotated_custom_grant2'
                }];
              assert.deepEqual(element.grantTypes, compare);
            });

            test('computes authQueryParameters', () => {
              assert.typeOf(element.authQueryParameters, 'array');
              assert.lengthOf(element.authQueryParameters, 5);
            });

            test('computes tokenQueryParameters', () => {
              assert.typeOf(element.tokenQueryParameters, 'array');
              assert.lengthOf(element.tokenQueryParameters, 2);
            });

            test('computes tokenBody', () => {
              assert.typeOf(element.tokenBody, 'array');
              assert.lengthOf(element.tokenBody, 2);
            });
          });
        });
      });

      suite('getSettings() - custom data', () => {
        [
          ['Full data model', false],
          ['Compact data model', true]
        ].forEach((setupItem) => {
          suite(setupItem[0], function() {
            let amf;
            let security;
            let element;
            suiteSetup(() => {
              return AmfLoader.load(0, setupItem[1])
              .then((model) => {
                amf = model[0];
                security = model[1];
              });
            });

            setup((done) => {
              clearCache();
              element = fixture('implicit');
              element.amfModel = amf;
              element.amfSettings = security;
              afterNextRender(element, () => {
                flush(() => done());
              });
            });

            test('Contains only required params', function() {
              const result = element.getSettings();
              assert.typeOf(result.customData.auth.parameters, 'array', 'auth params is an array');
              assert.lengthOf(result.customData.auth.parameters, 1, 'has one item');
            });

            test('Contains not required data when added', function() {
              const value = 1234;
              element.authQueryParameters[0].value = value;
              const result = element.getSettings();
              assert.lengthOf(result.customData.auth.parameters, 2, 'has two items');
              assert.equal(result.customData.auth.parameters[0].value, value);
            });

            test('Does not contain token data', function() {
              const result = element.getSettings();
              assert.isUndefined(result.customData.token);
            });

            test('deliveryMethod is set', () => {
              const result = element.getSettings();
              assert.equal(result.deliveryMethod, 'query', 'Custom value is set');
            });

            test('deliveryName is set', () => {
              const result = element.getSettings();
              assert.equal(result.deliveryName, 'access_token', 'Custom value is set');
            });

            test('deliveryMethod is restored to default', () => {
              element.amfSettings = undefined;
              const result = element.getSettings();
              assert.equal(result.deliveryMethod, 'header');
            });

            test('deliveryName is restored to default', () => {
              element.amfSettings = undefined;
              const result = element.getSettings();
              assert.equal(result.deliveryName, 'authorization');
            });
          });
        });
      });
    });
    </script>
  </body>
</html>
