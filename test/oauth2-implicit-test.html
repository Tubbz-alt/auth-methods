<!doctype html>
<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

    <script src="../../webcomponentsjs/webcomponents-lite.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <script src="../../iron-test-helpers/mock-interactions.js"></script>
    <script src="amf-loader.js"></script>
    <link rel="import" href="../auth-method-oauth2.html">
  </head>
  <body>
    <test-fixture id="implicit">
      <template>
        <auth-method-oauth2 grant-type="implicit"></auth-method-oauth2>
      </template>
    </test-fixture>
    <test-fixture id="empty">
      <template>
        <auth-method-oauth2></auth-method-oauth2>
      </template>
    </test-fixture>
    <script>
    /* global AmfLoader, MockInteractions, sinon */
    suite('Implicit grant type', () => {
      let element;
      const clientId = '821776164331-rserncqpdsq32lmbf5cfeolgcoujb6fm.apps.googleusercontent.com';
      const authorizationUri = 'https://accounts.google.com/o/oauth2/v2/auth';
      const redirectUri = 'https://redirect';
      const scopes = ['email', 'profile'];

      suite('Amf model', () => {
        let amf;
        suiteSetup(() => {
          return AmfLoader.load()
          .then((model) => amf = model);
        });
        let element;
        setup(() => {
          element = fixture('empty');
          element.amfSettings = amf;
        });

        test('Computes authorizationUri', () => {
          assert.equal(element.authorizationUri, 'https://auth.com');
        });

        test('Computes accessTokenUri', () => {
          assert.equal(element.accessTokenUri, 'https://token.com');
        });

        test('Computes scopes', () => {
          assert.deepEqual(element.scopes, ['profile', 'email']);
        });

        test('Computes grant types', () => {
          const compare = [{
              type: 'implicit',
              label: 'Access token (browser flow)'
            }, {
              type: 'authorization_code',
              label: 'Authorization code (server flow)'
            }, {
              label: 'annotated_custom_grant',
              type: 'annotated_custom_grant'
            }, {
              label: 'annotated_custom_grant2',
              type: 'annotated_custom_grant2'
            }];
          assert.deepEqual(element.grantTypes, compare);
        });

        test('computes authQueryParameters', () => {
          assert.typeOf(element.authQueryParameters, 'array');
          assert.lengthOf(element.authQueryParameters, 5);
        });

        test('computes tokenQueryParameters', () => {
          assert.typeOf(element.tokenQueryParameters, 'array');
          assert.lengthOf(element.tokenQueryParameters, 2);
        });

        test('computes tokenBody', () => {
          assert.typeOf(element.tokenBody, 'array');
          assert.lengthOf(element.tokenBody, 2);
        });
      });

      suite('Validation', () => {
        setup((done) => {
          element = fixture('implicit');
          element.clientId = clientId;
          element.authorizationUri = authorizationUri;
          Polymer.RenderStatus.afterNextRender(this, () => {
            done();
          });
        });

        test('Should not be validated', () => {
          assert.isFalse(element.validate(), 'Active validation.');
        });

        test('Should be validated', (done) => {
          element.scopes = ['email', 'profile'];
          flush(() => {
            assert.isTrue(element.validate());
            done();
          });
        });

        test('Should not fire oauth2-token-requested event', () => {
          const spy = sinon.stub();
          element.addEventListener('oauth2-token-requested', spy);
          const button = element.shadowRoot.querySelector('.auth-button');
          MockInteractions.tap(button);
          assert.isFalse(spy.calledOnce);
        });

        test('Fire oauth2-token-requested event when validated', (done) => {
          element.scopes = ['email', 'profile'];
          flush(() => {
            const spy = sinon.stub();
            element.addEventListener('oauth2-token-requested', spy);
            const button = element.shadowRoot.querySelector('.auth-button');
            MockInteractions.tap(button);
            assert.isTrue(spy.calledOnce);
            done();
          });
        });
      });

      suite('Fields visibility', () => {
        setup((done) => {
          element = fixture('implicit');
          Polymer.RenderStatus.afterNextRender(this, () => {
            flush(() => done());
          });
        });

        test('Step 1 is closed per auto selection', () => {
          assert.isTrue(element.isSelectedType);
          const node = element.shadowRoot.querySelector('auth-method-step[step="1"]');
          assert.isTrue(node.inactive);
        });

        test('Client id is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="clientid"]');
          assert.isTrue(node.required);
        });

        test('Client id is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="clientid"]');
          assert.isTrue(node.required);
        });

        test('Client secret is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="clientsecret"]');
          assert.isTrue(node.required);
        });

        test('Client secret is disabled', () => {
          const node = element.shadowRoot.querySelector('[data-input="clientsecret"]');
          assert.isTrue(node.disabled);
        });

        test('Client secret is hidden', () => {
          const node = element.shadowRoot.querySelector('[data-input="clientsecret"]');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'none');
        });

        test('Advanced settings checkbox is not rendered', () => {
          const node = element.shadowRoot.querySelector('.adv-settings-input');
          assert.notOk(node);
        });

        test('Authorization URI is not hidden', () => {
          const node = element.shadowRoot.querySelector('[data-input="authuri"]');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'block');
        });

        test('Authorization URI is not disabled', () => {
          const node = element.shadowRoot.querySelector('[data-input="authuri"]');
          assert.isFalse(node.disabled);
        });

        test('Authorization URI is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="authuri"]');
          assert.isTrue(node.required);
        });

        test('Access token URI is hidden', () => {
          const node = element.shadowRoot.querySelector('[data-input="tokenuri"]');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'none');
        });

        test('Access token URI is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="tokenuri"]');
          assert.isTrue(node.required);
        });

        test('Access token URI is disabled', () => {
          const node = element.shadowRoot.querySelector('[data-input="tokenuri"]');
          assert.isTrue(node.disabled);
        });

        test('Username is hidden', () => {
          const node = element.shadowRoot.querySelector('[data-input="username"]');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'none');
        });

        test('Username is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="username"]');
          assert.isTrue(node.required);
        });

        test('Username is disabled', () => {
          const node = element.shadowRoot.querySelector('[data-input="username"]');
          assert.isTrue(node.disabled);
        });

        test('Password is hidden', () => {
          const node = element.shadowRoot.querySelector('[data-input="password"]');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'none');
        });

        test('Password is required', () => {
          const node = element.shadowRoot.querySelector('[data-input="password"]');
          assert.isTrue(node.required);
        });

        test('Password is disabled', () => {
          const node = element.shadowRoot.querySelector('[data-input="password"]');
          assert.isTrue(node.disabled);
        });

        test('Scope selector is not hidden', () => {
          const node = element.shadowRoot.querySelector('oauth2-scope-selector');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'block');
        });

        test('Request access token button is rendered', () => {
          const node = element.shadowRoot.querySelector('.authorize-actions');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'block');
        });

        test('current-token section is hidden', () => {
          const node = element.shadowRoot.querySelector('.current-token');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'none');
        });
      });

      suite('Events', () => {
        setup((done) => {
          element = fixture('implicit');
          element.clientId = clientId;
          element.authorizationUri = authorizationUri;
          element.redirectUri = redirectUri;
          element.scopes = ['email', 'profile'];
          Polymer.RenderStatus.afterNextRender(this, () => {
            flush(() => {
              done();
            });
          });
        });

        test('oauth2-token-requested event contains state parameter', () => {
          let eventData;
          element.addEventListener('oauth2-token-requested', function clb(e) {
            element.removeEventListener('oauth2-token-requested', clb);
            eventData = e.detail;
          });
          let button = element.shadowRoot.querySelector('.auth-button');
          MockInteractions.tap(button);
          assert.typeOf(eventData.state, 'string');
        });

        test('oauth2-token-requested event contains all required data', (done) => {
          element.addEventListener('oauth2-token-requested', function clb(e) {
            element.removeEventListener('oauth2-token-requested', clb);
            assert.equal(e.detail.type, 'implicit', 'type is set');
            assert.equal(e.detail.clientId, clientId, 'clientId is set');
            assert.equal(e.detail.accessToken, '', 'accessToken is empty');
            assert.typeOf(e.detail.customData, 'object', 'customData is set');
            assert.equal(e.detail.authorizationUri, authorizationUri, 'authorizationUri is set');
            assert.equal(e.detail.redirectUri, redirectUri, 'redirectUri is set');
            assert.typeOf(e.detail.scopes, 'array', 'scopes is set');
            done();
          });
          element.authorize();
        });
      });

      suite('getSettings()', () => {
        let element;
        setup(() => {
          element = fixture('implicit');
          element.clientId = clientId;
          element.authorizationUri = authorizationUri;
          element.redirectUri = redirectUri;
          element.scopes = scopes;
        });

        test('Returns an object', () => {
          const result = element.getSettings();
          assert.typeOf(result, 'object');
        });

        test('type is set', () => {
          const result = element.getSettings();
          assert.equal(result.type, element.grantType);
        });

        test('clientId is set', () => {
          const result = element.getSettings();
          assert.equal(result.clientId, clientId);
        });

        test('accessToken is set', () => {
          let result = element.getSettings();
          assert.equal(result.accessToken, '', 'Token value is empty');
          element.accessToken = 'test-token';
          result = element.getSettings();
          assert.equal(result.accessToken, element.accessToken, 'Token value is set');
        });

        test('authorizationUri is set', () => {
          const result = element.getSettings();
          assert.equal(result.authorizationUri, authorizationUri);
        });

        test('redirectUri is set', () => {
          const result = element.getSettings();
          assert.equal(result.redirectUri, redirectUri);
        });

        test('scopes is set', () => {
          const result = element.getSettings();
          assert.isTrue(result.scopes === scopes);
        });

        test('Custom values are empty', function() {
          const result = element.getSettings();
          assert.isUndefined(result.customData.auth.parameters, 'auth params is not set');
          assert.isUndefined(result.customData.token, 'token is not set');
        });

        test('deliveryMethod is set', () => {
          const result = element.getSettings();
          assert.equal(result.deliveryMethod, 'header', 'default value is set');
        });

        test('deliveryName is set', () => {
          const result = element.getSettings();
          assert.equal(result.deliveryName, 'authorization', 'default value is set');
        });
      });

      suite('getSettings() - custom data', () => {
        let amf;
        suiteSetup(() => {
          return AmfLoader.load()
          .then((model) => amf = model);
        });

        let element;
        setup((done) => {
          element = fixture('implicit');
          element.amfSettings = amf;
          Polymer.RenderStatus.afterNextRender(this, () => {
            flush(() => done());
          });
        });

        test('Contains only required params', function() {
          const result = element.getSettings();
          assert.typeOf(result.customData.auth.parameters, 'array', 'auth params is an array');
          assert.lengthOf(result.customData.auth.parameters, 1, 'has one item');
        });

        test('Contains not required data when added', function() {
          const value = 'test-aq';
          element.authQueryParameters[3].value = value;
          const result = element.getSettings();
          assert.lengthOf(result.customData.auth.parameters, 2, 'has two items');
          assert.equal(result.customData.auth.parameters[1].value, value);
        });

        test('Does not contain token data', function() {
          const result = element.getSettings();
          assert.isUndefined(result.customData.token);
        });

        test('deliveryMethod is set', () => {
          const result = element.getSettings();
          assert.equal(result.deliveryMethod, 'query', 'Custom value is set');
        });

        test('deliveryName is set', () => {
          const result = element.getSettings();
          assert.equal(result.deliveryName, 'access_token', 'Custom value is set');
        });

        test('deliveryMethod is restored to default', () => {
          element.amfSettings = undefined;
          const result = element.getSettings();
          assert.equal(result.deliveryMethod, 'header');
        });

        test('deliveryName is restored to default', () => {
          element.amfSettings = undefined;
          const result = element.getSettings();
          assert.equal(result.deliveryName, 'authorization');
        });
      });
    });
    </script>
  </body>
</html>
